use crate::serialization_hybrid::{Pair, Product}; // Size removed, Array was already commented out
use crate::traits::group::CryptoGroup;
use hybrid_array::typenum::{U2, U3, U4};
// Array might be unused now directly here, but FSerializable methods will use it via crate::serialization_hybrid::Array
// use hybrid_array::Array;
use exact_derive::FSerializable;

/* Begin non macro version */
 // This comment will be inaccurate after the change
 // The first three lines also exist in the version using a macro
type Commitment<G> = Product<Product<<G as CryptoGroup>::Element, U2>, U3>;
type Response<G> = Product<<G as CryptoGroup>::Scalar, U4>;
type BitProof_<G> = Pair<Commitment<G>, Response<G>>;

// This line will be the same except for #[derive(FSerializable)] annotation
#[derive(FSerializable)]
pub struct BitProof<G: CryptoGroup>(BitProof_<G>); // Fixed turbofish

// The rest of the code should be generated by the macro
// type BitProofSize<G> = <BitProof_<G> as Size>::SizeType; // Removed
// impl<G: CryptoGroup> Size for BitProof<G>  // Removed
// where BitProof_<G>: Size { // Removed
//     type SizeType = BitProofSize<G>; // Removed
// } // Removed

// impl<G: CryptoGroup> crate::serialization_hybrid::FSerializable<BitProofSize<G>> for BitProof<G> // Removed
// where // Removed
//     BitProof_<G>: Size, // Removed
//     BitProof_<G>: crate::serialization_hybrid::FSerializable<BitProofSize<G>>, // Removed
// { // Removed
//     fn serialize(&self) -> Array<u8, BitProofSize<G>> { // Removed
//         self.0.serialize() // Removed
//     } // Removed

//     fn deserialize( // Removed
//         bytes: Array<u8, BitProofSize<G>>, // Removed
//     ) -> Result<Self, crate::serialization_hybrid::Error> { // Removed
//         let pair = BitProof_::<G>::deserialize(bytes); // Removed

//         Ok(BitProof(pair?)) // Removed
//     } // Removed
// } // Removed
/* End non macro version */ // This comment will be inaccurate

/*
This is how we would like to write the same code using a macro:

---------------- Begin code using macro ------------
// use exact_derive::FSerializable; // This is now at the top of the file

// type Commitment<G> = Product<Product<<G as CryptoGroup>::Element, U2>, U3>; // These are defined above
// type Response<G> = Product<<G as CryptoGroup>::Scalar, U4>; // These are defined above
// type BitProof_<G> = Pair<Commitment<G>, Response<G>>; // These are defined above
// #[derive(FSerializable)] // This is applied above
// pub struct BitProof<G: CryptoGroup>(BitProof_<G>); // This is defined above
---------------- End code using macro ------------
*/
